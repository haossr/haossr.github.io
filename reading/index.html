---
layout: null
---
<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-R7BNJ90QEW"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-R7BNJ90QEW');
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Reading | {{ site.title }}</title>
  <link rel="shortcut icon" href="{{ site.favicon }}" type="image/vnd.microsoft.icon">
  <link rel="stylesheet" href="/assets/css/styles.css">
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic" rel="stylesheet" type="text/css">
</head>

<body class="reading-body">
  <div class="reading-page">
    <div class="reading-card">
      <div class="reading-top">
        <a class="reading-back" href="/">&larr; Back home</a>
        <div class="reading-actions top-right">
          <div id="lang-switcher" class="lang-switcher" aria-label="Switch language">
            <button type="button" data-lang="zh" class="lang-button" aria-label="中文">中</button>
            <div class="lang-dropdown">
              <button
                type="button"
                id="lang-trigger"
                class="lang-button lang-trigger"
                aria-label="More languages"
                aria-haspopup="true"
                aria-expanded="false"
              >
                EN ▾
              </button>
              <div class="lang-menu" id="lang-menu" role="menu">
                <button type="button" data-lang="en" class="lang-menu-item" role="menuitem">EN</button>
                <button type="button" data-lang="es" class="lang-menu-item" role="menuitem">ES</button>
                <button type="button" data-lang="fr" class="lang-menu-item" role="menuitem">FR</button>
              </div>
            </div>
          </div>
          <button id="share-reading" class="share-button" type="button" disabled aria-label="Share this excerpt">
            <svg class="share-icon" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7a3.03 3.03 0 0 0 0-1.39l7.05-4.11A3 3 0 1 0 15 5a3.01 3.01 0 0 0 .09.7L8.04 9.81a3 3 0 1 0 0 4.38l7.05 4.11a3 3 0 1 0 2.91-2.22z" fill="currentColor"/>
            </svg>
          </button>
        </div>
      </div>
      <div id="reading-content" class="reading-content">
        <p class="reading-loading">Loading a random excerpt...</p>
      </div>
    </div>
  </div>
  <div id="reading-timeline" class="reading-timeline" aria-hidden="true">
    <div class="timeline-rail">
      <div class="timeline-markers"></div>
      <div class="timeline-year-grid"></div>
      <div class="timeline-thumb"></div>
    </div>
    <div id="timeline-label" class="timeline-label">--</div>
  </div>
  <div id="share-toast" class="share-toast" role="status" aria-live="polite"></div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const contentEl = document.getElementById('reading-content');
      const shareBtn = document.getElementById('share-reading');
      const shareToast = document.getElementById('share-toast');
      const langSwitcher = document.getElementById('lang-switcher');
      const mainLangButtons = Array.from(
        langSwitcher?.querySelectorAll('.lang-button[data-lang]') || []
      );
      const dropdown = langSwitcher?.querySelector('.lang-dropdown');
      const langMenu = langSwitcher?.querySelector('.lang-menu');
      const langTrigger = document.getElementById('lang-trigger');
      const langMenuItems = Array.from(
        langSwitcher?.querySelectorAll('.lang-menu-item[data-lang]') || []
      );
      const timelineEl = document.getElementById('reading-timeline');
      const timelineRail = timelineEl?.querySelector('.timeline-rail');
      const timelineThumb = timelineEl?.querySelector('.timeline-thumb');
      const timelineMarkers = timelineEl?.querySelector('.timeline-markers');
      const timelineYearGrid = timelineEl?.querySelector('.timeline-year-grid');
      const timelineLabel = document.getElementById('timeline-label');
      const urlParams = new URLSearchParams(window.location.search);
      const initialId = urlParams.get('id');
      const urlLang = (urlParams.get('lang') || '').toLowerCase();

      const LANG_CONFIG = {
        zh: { label: '中', file: '/assets/json/reading.json' },
        en: { label: 'EN', file: '/assets/json/reading-en.json' },
        es: { label: 'ES', file: '/assets/json/reading-es.json' },
        fr: { label: 'FR', file: '/assets/json/reading-fr.json' }
      };
      const SUPPORTED_LANGS = Object.keys(LANG_CONFIG);

      let currentLang = 'en';
      let currentShareUrl = '';
      let currentShareTitle = '';
      let readings = [];
      let history = [];
      let historyPos = -1;
      let toastTimer = null;
      let baseIds = [];
      let baseKeepIndices = [];
      const languageCache = {};
      let timelineData = [];
      let timelineMin = null;
      let timelineMax = null;
      let isDraggingTimeline = false;
      let lastTimelineIdx = null;

      const detectPreferredLang = () => {
        if (SUPPORTED_LANGS.includes(urlLang)) return urlLang;
        const navLang = (navigator.language || '').toLowerCase();
        const match = SUPPORTED_LANGS.find((lang) => navLang.startsWith(lang));
        return match || 'en';
      };

      const closeDropdown = () => {
        if (dropdown) {
          dropdown.classList.remove('is-open');
        }
        if (langTrigger) {
          langTrigger.setAttribute('aria-expanded', 'false');
        }
      };

      const setActiveLangButton = () => {
        const allButtons = [...mainLangButtons, ...langMenuItems];
        allButtons.forEach((btn) => {
          const active = btn.dataset.lang === currentLang;
          btn.classList.toggle('is-active', active);
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        });
        if (langTrigger) {
          const label = ['en', 'es', 'fr'].includes(currentLang) ? currentLang.toUpperCase() : 'EN';
          langTrigger.textContent = `${label} ▾`;
          langTrigger.classList.toggle('is-active', ['en', 'es', 'fr'].includes(currentLang));
          langTrigger.setAttribute('aria-expanded', dropdown?.classList.contains('is-open') ? 'true' : 'false');
        }
      };

      const setShareDisabled = (disabled) => {
        if (shareBtn) shareBtn.disabled = disabled;
      };
      setShareDisabled(true);

      const setStatus = (message) => {
        setShareDisabled(true);
        contentEl.innerHTML = '';
        const p = document.createElement('p');
        p.className = 'reading-loading';
        p.textContent = message;
        contentEl.appendChild(p);
      };

      const sanitizeJson = (text) => {
        // reading.json occasionally includes raw control characters inside strings; escape them before parsing.
        let safe = '';
        let inString = false;
        let escape = false;
        for (const ch of text) {
          if (inString) {
            if (escape) {
              escape = false;
              safe += ch;
              continue;
            }
            if (ch === '\\') {
              escape = true;
              safe += ch;
              continue;
            }
            if (ch === '"') {
              inString = false;
              safe += ch;
              continue;
            }
            if (ch === '\n') {
              safe += '\\n';
              continue;
            }
            if (ch === '\r') {
              safe += '\\r';
              continue;
            }
            if (ch === '\t') {
              safe += '\\t';
              continue;
            }
            safe += ch;
          } else {
            if (ch === '"') {
              inString = true;
            }
            safe += ch;
          }
        }
        return safe;
      };

      const debounce = (fn, wait = 150) => {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => fn(...args), wait);
        };
      };

      const fitTitle = () => {
        const titleEl = contentEl.querySelector('.reading-title');
        if (!titleEl) return;
        const prefersSingleLine = currentLang && currentLang !== 'zh';
        const baseFont = parseFloat(window.getComputedStyle(titleEl).fontSize) || 16;
        const minSingle = 10;
        const minMulti = 12;
        const width = titleEl.clientWidth || titleEl.scrollWidth;
        if (!width) return;

        const measure = (font, whiteSpace) => {
          const clone = titleEl.cloneNode(true);
          const style = clone.style;
          style.position = 'absolute';
          style.visibility = 'hidden';
          style.zIndex = '-1';
          style.whiteSpace = whiteSpace;
          style.display = 'block';
          style.overflow = 'visible';
          style.maxWidth = `${width}px`;
          style.width = `${width}px`;
          style.fontSize = `${font}px`;
          style.webkitLineClamp = 'unset';
          style.webkitBoxOrient = 'unset';
          document.body.appendChild(clone);
          const computed = window.getComputedStyle(clone);
          const lineHeight = parseFloat(computed.lineHeight) || font * 1.2;
          const result = {
            scrollWidth: clone.scrollWidth,
            scrollHeight: clone.scrollHeight,
            lineHeight
          };
          clone.remove();
          return result;
        };

        let chosen = baseFont;
        let singleLine = false;

        if (prefersSingleLine) {
          for (let font = baseFont; font >= minSingle; font -= 0.5) {
            const { scrollWidth } = measure(font, 'nowrap');
            if (scrollWidth <= width + 1) {
              chosen = font;
              singleLine = true;
              break;
            }
          }
        }

        if (!singleLine) {
          for (let font = baseFont; font >= minMulti; font -= 0.5) {
            const { scrollHeight, lineHeight, scrollWidth } = measure(font, 'normal');
            const lines = Math.ceil(scrollHeight / lineHeight);
            const fitsWidth = scrollWidth <= width + 1;
            if (lines <= 2 && fitsWidth) {
              chosen = font;
              break;
            }
          }
        }

        titleEl.style.setProperty('--title-size', `${Math.min(chosen, baseFont)}px`);
        if (singleLine) {
          titleEl.classList.add('single-line');
        } else {
          titleEl.classList.remove('single-line');
        }
      };

      const formatDate = (timestamp) => {
        if (!timestamp) return 'Date unknown';
        const date = new Date(Number(timestamp) * 1000);
        if (Number.isNaN(date.getTime())) return 'Date unknown';
        return date.toISOString().split('T')[0];
      };

      const getTimestampMs = (item) => {
        const ts = Number(item.createdAt || item.finishTime || item.startTime || 0);
        return Number.isFinite(ts) ? ts * 1000 : null;
      };

      const computeId = (item, idx) => {
        const parts = [item.bookId, item.range, item.createdAt, item.isbn, item.title]
          .filter(Boolean)
          .join('|');
        const source = parts || `idx-${idx}`;
        let hash = 0;
        for (let i = 0; i < source.length; i += 1) {
          hash = (hash << 5) - hash + source.charCodeAt(i);
          hash |= 0;
        }
        return `r${Math.abs(hash)}`;
      };

      const buildShareUrl = (id) => {
        const url = new URL(window.location.href);
        url.searchParams.set('id', id);
        url.searchParams.set('lang', currentLang);
        return url.toString();
      };

      const updateShareData = (reading) => {
        if (!reading) {
          setShareDisabled(true);
          return;
        }
        const id = reading.__id || computeId(reading, Math.max(historyPos, 0));
        currentShareUrl = buildShareUrl(id);
        currentShareTitle = reading.title || 'Reading note';
        setShareDisabled(false);
        if (shareBtn) {
          shareBtn.dataset.shareUrl = currentShareUrl;
        }
        if (window.history && window.history.replaceState) {
          const next = new URL(currentShareUrl);
          window.history.replaceState(null, '', `${next.pathname}${next.search}`);
        }
      };

      const flashShareMessage = (message) => {
        if (!shareToast) return;
        shareToast.textContent = message;
        shareToast.classList.add('visible');
        if (toastTimer) clearTimeout(toastTimer);
        toastTimer = setTimeout(() => {
          shareToast.classList.remove('visible');
        }, 1800);
      };

      const copyViaTextarea = (text) => {
        try {
          const textarea = document.createElement('textarea');
          textarea.value = text;
          textarea.setAttribute('readonly', '');
          textarea.style.position = 'absolute';
          textarea.style.left = '-9999px';
          document.body.appendChild(textarea);
          textarea.select();
          const successful = document.execCommand && document.execCommand('copy');
          document.body.removeChild(textarea);
          return successful;
        } catch (error) {
          return false;
        }
      };

      const shareCurrent = async () => {
        if (!currentShareUrl) {
          flashShareMessage('No link to share');
          return;
        }
        const url = currentShareUrl;
        const title = currentShareTitle || document.title;
        const isMobile =
          /iphone|ipad|ipod|android|mobile/i.test(navigator.userAgent || '') || false;
        const canNativeShare =
          isSecureContext &&
          isMobile &&
          navigator.share &&
          (!navigator.canShare || navigator.canShare({ url }));
        const tryClipboardApi = async () => {
          if (navigator.clipboard?.writeText) {
            try {
              await navigator.clipboard.writeText(url);
              flashShareMessage('Link copied');
              return true;
            } catch (error) {
              // ignore and fall back
            }
          }
          return false;
        };

        const tryLegacyCopy = () => {
          const copied = copyViaTextarea(url);
          if (copied) {
            flashShareMessage('Link copied');
          }
          return copied;
        };

        if (canNativeShare) {
          try {
            await navigator.share({
              url,
              title,
              text: 'Sharing a highlight',
            });
            flashShareMessage('Link shared');
            return;
          } catch (error) {
            if (error?.name === 'AbortError') {
              // fall back to copy
            } else {
              // fall through to clipboard/prompt
            }
          }
        }

        try {
          const copied = await tryClipboardApi();
          if (copied) return;
        } catch (error) {
          // continue to legacy/prompt
        }

        if (tryLegacyCopy()) return;

        if (window.prompt) {
          window.prompt('Copy this link', url);
          flashShareMessage('Link ready');
        } else {
          flashShareMessage('Share failed');
        }
      };

      const renderReading = (reading) => {
        const {
          markText,
          title,
          author,
          isbn,
          createdAt,
          finishTime,
          startTime,
          coverUrl,
          cover,
          chapterTitle
        } = reading;

        contentEl.innerHTML = '';

        const mainEl = document.createElement('div');
        mainEl.className = 'reading-main';

        const goodreadsHref = isbn ? `https://www.goodreads.com/book/isbn/${isbn}` : null;
        const coverSrc = coverUrl || cover;
        if (coverSrc) {
          const coverEl = document.createElement('img');
          coverEl.className = 'reading-cover';
          coverEl.src = coverSrc;
          coverEl.alt = title ? `${title} cover` : 'Book cover';
          coverEl.loading = 'lazy';
          coverEl.decoding = 'async';
          coverEl.addEventListener('error', () => {
            coverEl.style.display = 'none';
          });
          if (goodreadsHref) {
            const coverLink = document.createElement('a');
            coverLink.className = 'reading-cover-link';
            coverLink.href = goodreadsHref;
            coverLink.target = '_blank';
            coverLink.rel = 'noopener noreferrer';
            coverLink.appendChild(coverEl);
            mainEl.appendChild(coverLink);
          } else {
            mainEl.appendChild(coverEl);
          }
        }

        const detailsEl = document.createElement('div');
        detailsEl.className = 'reading-details';

        const quoteEl = document.createElement('div');
        quoteEl.className = 'reading-quote';
        quoteEl.textContent = markText && markText.trim() ? markText.trim() : 'No quote available.';
        detailsEl.appendChild(quoteEl);

        const formattedDate = formatDate(createdAt || finishTime || startTime);
        const datePart = formattedDate === 'Date unknown' ? '' : formattedDate;

        const metaWrapper = document.createElement('div');
        metaWrapper.className = 'reading-meta';

        const titleEl = document.createElement('div');
        titleEl.className = 'reading-title';
        const displayTitle = [title, chapterTitle, datePart].filter(Boolean).join(' · ') || 'Untitled';
        if (goodreadsHref) {
          const titleLink = document.createElement('a');
          titleLink.className = 'reading-title-link';
          titleLink.href = goodreadsHref;
          titleLink.target = '_blank';
          titleLink.rel = 'noopener noreferrer';
          titleLink.textContent = displayTitle;
          titleEl.appendChild(titleLink);
        } else {
          titleEl.textContent = displayTitle;
        }

        const authorEl = document.createElement('div');
        authorEl.className = 'reading-author';
        authorEl.textContent = author ? `by ${author}` : '';

        metaWrapper.appendChild(titleEl);
        metaWrapper.appendChild(authorEl);

        detailsEl.appendChild(metaWrapper);

        mainEl.appendChild(detailsEl);
        contentEl.appendChild(mainEl);
        updateShareData(reading);
        updateTimelineThumb();
        requestAnimationFrame(() => fitTitle());
      };

      const renderFromHistory = () => {
        const idx = history[historyPos];
        const choice = readings[idx];
        if (!choice) return;
        renderReading(choice);
      };

      const pushToHistory = (idx) => {
        history = history.slice(0, historyPos + 1);
        history.push(idx);
        historyPos = history.length - 1;
        renderFromHistory();
      };

      const pickRandom = () => {
        if (!readings.length) {
          setStatus('No excerpts available yet.');
          return;
        }
        const choiceIdx = Math.floor(Math.random() * readings.length);
        pushToHistory(choiceIdx);
      };

      const goBack = () => {
        if (historyPos > 0) {
          historyPos -= 1;
          renderFromHistory();
        }
      };

      const goForward = () => {
        if (historyPos < history.length - 1) {
          historyPos += 1;
          renderFromHistory();
        } else {
          pickRandom();
        }
      };

      const jumpToIndex = (idx) => {
        if (idx == null || Number.isNaN(idx) || idx < 0 || idx >= readings.length) return;
        history = history.slice(0, historyPos + 1);
        history.push(idx);
        historyPos = history.length - 1;
        renderFromHistory();
      };

      const jumpChrono = (delta) => {
        if (!timelineData.length) return;
        const currentIdx = history[historyPos];
        const currentEntry = getTimelineEntryByIdx(currentIdx) || timelineData[0];
        const pos = timelineData.findIndex((entry) => entry.idx === currentEntry.idx);
        if (pos === -1) return;
        const target = timelineData[pos + delta];
        if (target) {
          jumpToIndex(target.idx);
        }
      };

      const prepareReadings = (parsed, options = {}) => {
        const { idsSource = null, pickIndices = null, recordIndices = false } = options;
        const picks = pickIndices ? new Set(pickIndices) : null;
        const filtered = [];
        const keptIdx = [];

        parsed.forEach((item, idx) => {
          const keep = picks
            ? picks.has(idx)
            : item &&
              item.markText &&
              item.markText.trim().length > 0 &&
              !item.markText.includes('封面');

          if (!keep) return;
          filtered.push({ ...item });
          if (recordIndices) keptIdx.push(idx);
        });

        const mapped = filtered.map((item, idx) => ({
          ...item,
          __id:
            idsSource && idsSource[idx] ? idsSource[idx] : computeId(item, idx)
        }));

        return { items: mapped, keptIndices: keptIdx };
      };

      const buildTimelineBase = (items) => {
        const mapped = items
          .map((item, idx) => ({ idx, ts: getTimestampMs(item) }))
          .filter(({ ts }) => ts && Number.isFinite(ts))
          .sort((a, b) => a.ts - b.ts);
        if (!mapped.length) {
          timelineData = [];
          timelineMin = null;
          timelineMax = null;
          return;
        }
        timelineData = mapped;
        timelineMin = mapped[0].ts;
        timelineMax = mapped[mapped.length - 1].ts || timelineMin + 1;
      };

      const formatTimelineLabel = (ts) => {
        if (!ts) return '--';
        const d = new Date(ts);
        const year = d.getUTCFullYear();
        const month = `${d.getUTCMonth() + 1}`.padStart(2, '0');
        return `${year} · ${month}`;
      };

      const getTimelineEntryByIdx = (idx) =>
        timelineData.find((item) => item.idx === idx) || null;

      const setTimelineVisibility = (visible) => {
        if (!timelineEl) return;
        timelineEl.classList.toggle('is-hidden', !visible);
      };
      setTimelineVisibility(false);

      const renderYearGrid = () => {
        if (!timelineYearGrid) return;
        timelineYearGrid.innerHTML = '';
        if (!timelineData.length || !timelineMin || !timelineMax) return;
        const firstYear = new Date(timelineMin).getUTCFullYear();
        const lastYear = new Date(timelineMax).getUTCFullYear();
        const range = Math.max(1, timelineMax - timelineMin);
        const frag = document.createDocumentFragment();
        for (let year = firstYear; year <= lastYear; year += 1) {
          const ts = Date.UTC(year, 0, 1);
          const ratio = Math.max(0, Math.min(1, (ts - timelineMin) / range));
          const line = document.createElement('div');
          line.className = 'timeline-year-line';
          line.style.top = `${ratio * 100}%`;
          const label = document.createElement('div');
          label.className = 'timeline-year-label';
          label.textContent = year;
          label.style.top = `${ratio * 100}%`;
          line.appendChild(label);
          frag.appendChild(line);
        }
        timelineYearGrid.appendChild(frag);
      };

      const renderTimelineMarkers = () => {
        if (!timelineMarkers) return;
        timelineMarkers.innerHTML = '';
        if (!timelineData.length || !timelineMin || !timelineMax) return;
        const range = Math.max(1, timelineMax - timelineMin);
        const frag = document.createDocumentFragment();
        timelineData.forEach((item) => {
          const ratio = Math.max(0, Math.min(1, (item.ts - timelineMin) / range));
          const dot = document.createElement('div');
          dot.className = 'timeline-mark';
          dot.style.top = `${ratio * 100}%`;
          frag.appendChild(dot);
        });
        timelineMarkers.appendChild(frag);
      };

      const getRatioFromTs = (ts) => {
        if (!timelineMin || !timelineMax) return 0;
        const range = Math.max(1, timelineMax - timelineMin);
        return Math.max(0, Math.min(1, (ts - timelineMin) / range));
      };

      const setThumbByEntry = (entry) => {
        if (!entry || !timelineThumb || !timelineLabel) return;
        const ratio = getRatioFromTs(entry.ts || timelineMin);
        const percent = ratio * 100;
        timelineThumb.style.top = `${percent}%`;
        timelineLabel.style.top = `${percent}%`;
        timelineLabel.textContent = formatTimelineLabel(entry.ts);
      };

      const updateTimelineThumb = () => {
        if (
          !timelineEl ||
          !timelineRail ||
          !timelineThumb ||
          !timelineData.length ||
          !timelineMin ||
          !timelineMax
        ) {
          setTimelineVisibility(false);
          return;
        }
        setTimelineVisibility(true);
        const currentIdx = history[historyPos];
        const entry =
          getTimelineEntryByIdx(currentIdx) ||
          timelineData[Math.max(0, Math.min(timelineData.length - 1, Math.floor(timelineData.length / 2)))];
        setThumbByEntry(entry);
      };

      const findEntryByRatio = (ratio) => {
        if (!timelineData.length || !timelineMin || !timelineMax) return null;
        const clamped = Math.max(0, Math.min(1, ratio));
        const targetTs = timelineMin + clamped * (timelineMax - timelineMin);
        let closest = timelineData[0];
        let bestDiff = Math.abs(closest.ts - targetTs);
        for (let i = 1; i < timelineData.length; i += 1) {
          const diff = Math.abs(timelineData[i].ts - targetTs);
          if (diff < bestDiff) {
            bestDiff = diff;
            closest = timelineData[i];
          }
        }
        return closest;
      };

      const findIndexByRatio = (ratio) => {
        if (!timelineData.length || !timelineMin || !timelineMax) return null;
        const clamped = Math.max(0, Math.min(1, ratio));
        const targetTs = timelineMin + clamped * (timelineMax - timelineMin);
        let closest = timelineData[0];
        let bestDiff = Math.abs(closest.ts - targetTs);
        for (let i = 1; i < timelineData.length; i += 1) {
          const diff = Math.abs(timelineData[i].ts - targetTs);
          if (diff < bestDiff) {
            bestDiff = diff;
            closest = timelineData[i];
          }
        }
        return closest?.idx ?? null;
      };

      const handleTimelinePosition = (clientY) => {
        if (!timelineRail) return null;
        const rect = timelineRail.getBoundingClientRect();
        if (!rect.height) return null;
        const ratio = (clientY - rect.top) / rect.height;
        return Math.max(0, Math.min(1, ratio));
      };

      const activateTimeline = () => {
        if (timelineEl) timelineEl.classList.add('is-active');
      };

      const deactivateTimeline = () => {
        if (timelineEl && !isDraggingTimeline) {
          timelineEl.classList.remove('is-active');
        }
      };

      const attachTimelineControls = () => {
        if (!timelineEl || !timelineRail || !timelineThumb) return;

        const applyPosition = (clientY) => {
          const ratio = handleTimelinePosition(clientY);
          if (ratio == null) return;
          const entry = findEntryByRatio(ratio);
          if (!entry) return;
          setThumbByEntry(entry);
          if (entry.idx !== lastTimelineIdx) {
            lastTimelineIdx = entry.idx;
            jumpToIndex(entry.idx);
          }
        };

        const endDrag = () => {
          isDraggingTimeline = false;
          lastTimelineIdx = null;
          timelineEl.classList.remove('is-dragging');
          deactivateTimeline();
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('touchmove', onMove, { passive: false });
          document.removeEventListener('mouseup', endDrag);
          document.removeEventListener('touchend', endDrag);
          document.removeEventListener('touchcancel', endDrag);
        };

        const onMove = (event) => {
          if (!isDraggingTimeline) return;
          const clientY =
            event.touches && event.touches.length ? event.touches[0].clientY : event.clientY;
          applyPosition(clientY);
          event.preventDefault();
        };

        const startDrag = (event) => {
          if (!timelineData.length) return;
          isDraggingTimeline = true;
          activateTimeline();
          timelineEl.classList.add('is-dragging');
          const clientY =
            event.touches && event.touches.length ? event.touches[0].clientY : event.clientY;
          applyPosition(clientY);
          document.addEventListener('mousemove', onMove);
          document.addEventListener('touchmove', onMove, { passive: false });
          document.addEventListener('mouseup', endDrag);
          document.addEventListener('touchend', endDrag);
          document.addEventListener('touchcancel', endDrag);
        };

        timelineRail.addEventListener('mousedown', (event) => {
          event.preventDefault();
          startDrag(event);
        });
        timelineRail.addEventListener('touchstart', (event) => {
          startDrag(event);
        });
        timelineThumb.addEventListener('mousedown', (event) => {
          event.preventDefault();
          startDrag(event);
        });
        timelineThumb.addEventListener('touchstart', (event) => {
          startDrag(event);
        });

        timelineEl.addEventListener('mouseenter', () => {
          if (!isDraggingTimeline) activateTimeline();
        });
        timelineEl.addEventListener('mouseleave', () => {
          deactivateTimeline();
        });
      };
      const fetchLanguageData = async (lang) => {
        if (languageCache[lang]) return languageCache[lang];
        const config = LANG_CONFIG[lang] || LANG_CONFIG.en;
        const response = await fetch(config.file);
        if (!response.ok) {
          throw new Error(`Failed to load ${config.file}`);
        }
        const cleaned = sanitizeJson(await response.text());
        const parsed = JSON.parse(cleaned);
        const idsSource = lang === 'zh' ? null : baseIds.length ? baseIds : null;
        const picks = lang === 'zh' ? null : baseKeepIndices;
        if (lang !== 'zh' && (!baseKeepIndices || !baseKeepIndices.length)) {
          throw new Error('Base language not loaded; cannot align entries.');
        }
        const { items, keptIndices } = prepareReadings(parsed, {
          idsSource,
          pickIndices: picks,
          recordIndices: lang === 'zh'
        });
        if (lang === 'zh') {
          baseKeepIndices = keptIndices;
          if (!baseIds.length) {
            baseIds = items.map((item) => item.__id);
          }
          buildTimelineBase(items);
          renderTimelineMarkers();
          renderYearGrid();
        }
        languageCache[lang] = items;
        return items;
      };

      const ensureBase = async () => {
        if (!baseIds.length) {
          await fetchLanguageData('zh');
        }
      };

      const getCurrentId = () => {
        if (historyPos < 0) return null;
        const current = readings[history[historyPos]];
        return current?.__id || null;
      };

      const switchLanguage = async (lang, options = {}) => {
        const target = SUPPORTED_LANGS.includes(lang) ? lang : 'en';
        const desiredId = options.initialId || (options.keepId ? getCurrentId() : null);
        currentLang = target;
        setActiveLangButton();
        setStatus('Loading excerpts...');
        try {
          await ensureBase();
          const langReadings = await fetchLanguageData(target);
          readings = langReadings;
          history = [];
          historyPos = -1;

          const initialIdx = desiredId
            ? readings.findIndex((entry) => entry.__id === desiredId)
            : -1;

          if (initialIdx >= 0) {
            pushToHistory(initialIdx);
          } else {
            pickRandom();
          }
        } catch (error) {
          console.error(error);
          setStatus('Unable to load excerpts right now.');
        }
      };

        if (shareBtn) {
          shareBtn.addEventListener('click', () => {
            shareCurrent();
          });
        }

        if (mainLangButtons.length) {
          mainLangButtons.forEach((btn) => {
            btn.addEventListener('click', () => {
              const lang = btn.dataset.lang;
              closeDropdown();
              switchLanguage(lang, { keepId: true });
            });
          });
        }

        if (langTrigger && dropdown && langMenu) {
          langTrigger.addEventListener('click', () => {
            const isOpen = dropdown.classList.toggle('is-open');
            langTrigger.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
          });
          langMenuItems.forEach((btn) => {
            btn.addEventListener('click', () => {
              const lang = btn.dataset.lang;
              closeDropdown();
              switchLanguage(lang, { keepId: true });
            });
          });
          document.addEventListener('click', (event) => {
            if (!dropdown.contains(event.target)) {
              closeDropdown();
            }
          });
          document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
              closeDropdown();
            }
          });
        }

      document.addEventListener('keydown', (event) => {
        if (event.key === 'ArrowLeft') {
          event.preventDefault();
          goBack();
        } else if (event.key === 'ArrowRight') {
          event.preventDefault();
          goForward();
        } else if (event.key === 'ArrowUp') {
          event.preventDefault();
          jumpChrono(-1);
        } else if (event.key === 'ArrowDown') {
          event.preventDefault();
          jumpChrono(1);
        } else if (event.key === 'c' || event.key === 'C') {
          event.preventDefault();
          switchLanguage('zh', { keepId: true });
        } else if (event.key === 'e' || event.key === 'E') {
          event.preventDefault();
          switchLanguage('en', { keepId: true });
        } else if (event.key === 'f' || event.key === 'F') {
          event.preventDefault();
          switchLanguage('fr', { keepId: true });
        } else if (event.key === 's' || event.key === 'S') {
          event.preventDefault();
          switchLanguage('es', { keepId: true });
        }
      });

      const start = async () => {
        setActiveLangButton();
        await switchLanguage(detectPreferredLang(), { initialId });
        renderTimelineMarkers();
        renderYearGrid();
      };

      const handleResize = debounce(() => fitTitle(), 150);
      window.addEventListener('resize', handleResize);

      attachTimelineControls();
      start()
        .then(() => fitTitle())
        .catch((error) => {
          console.error(error);
          setStatus('Unable to load excerpts right now.');
        });
    });
  </script>
</body>

</html>
